<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../css/computations.css">
    <script defer src="https://pyscript.net/alpha/pyscript.js"></script>
</head>

<body>
    <h1>PyScript computation benchmark</h1>
    <py-script>
 import json
from js import console
from pyodide.http import open_url

# GET
start = time.time()
data = json.loads(open_url("https://raw.githubusercontent.com/kevinOcconer/million/main/million.json").read())
<!-- 
def mergeSort(arr):
    if len(arr) > 1:
 
         # Finding the mid of the array
        mid = len(arr)//2
 
        # Dividing the array elements
        L = arr[:mid]
 
        # into 2 halves
        R = arr[mid:]
 
        # Sorting the first half
        mergeSort(L)
 
        # Sorting the second half
        mergeSort(R)
 
        i = j = k = 0
 
        # Copy data to temp arrays L[] and R[]
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1
 
        # Checking if any element was left
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1
 
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1
print("Merge sort")
mid = time.time()
mergeSort(data)
end = time.time()
print(end-mid)
print("completed")    -->

<!-- matrix Multiplication -->

<!-- m1 = [[1,2],[3,4]]
m2 = [[5,6],[7,8]]

result = []
for i in range(2):
   row = []
   for j in range(2):
      row.append(0)
   result.append(row)
print("Matrix Multiplication:")
mid = time.time()
for i in range(2):
   for j in range(2):
      for k in range(2):
         result[i][j] += m1[i][k] * m2[k][j]
end = time.time()
print(end-mid) -->

<!-- DFS -->

 # this class represents a directed graph using adjacency list representation
 
<!--  
class Graph:
    # Constructor
    def __init__(self):
        # default dictionary to store graph
        self.graph = defaultdict(list)
 
    # Function to add an edge to graph
    def addEdge(self, u, v):
        self.graph[u].append(v)
    # A function used by DFS
 
    def DFSUtil(self, v, visited):
        # Mark the current node as visited and print it
        visited.add(v)
        print(v,end=" ")
 
        # recur for all the vertices adjacent to this vertex
        for neighbour in self.graph[v]:
            if neighbour not in visited:
                self.DFSUtil(neighbour, visited)
        # The function to do DFS traversal. It uses recursive DFSUtil
 
    def DFS(self):
        # create a set to store all visited vertices
        visited = set()
        # call the recursive helper function to print DFS traversal starting from all
        # vertices one by one
        for vertex in self.graph:
            if vertex not in visited:
                self.DFSUtil(vertex, visited)
# Driver code
# create a graph given in the above diagram
 
print("Following is Depth First Traversal \n")
g = Graph()
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(2, 3)
g.addEdge(3, 3)
print("DFS")
mid = time.time()
g.DFS()
end = time.time()
print(end-mid)  -->

<!-- Polynomial hash -->


class Hash:
    def __init__(self, s: str):
        self.p1, self.m1 = 31, 10**9 + 7
        self.p2, self.m2 = 37, 10**9 + 9
        self.hash1, self.hash2 = 0, 0
        self.compute_hashes(s)
    def compute_hashes(self, s: str):
        pow1, pow2 = 1, 1
        hash1, hash2 = 0, 0
        for ch in s:
            seed = 1 + ord(ch) - ord('a')
            hash1 = (hash1 + seed * pow1) % self.m1
            hash2 = (hash2 + seed * pow2) % self.m2
            pow1 = (pow1 * self.p1) % self.m1
            pow2 = (pow2 * self.p2) % self.m2
        self.hash1, self.hash2 = hash1, hash2

def __eq__(self, other):
    return self.hash1 == other.hash1 and self.hash2 == other.hash2

def __str__(self):
    return f'({self.hash1}, {self.hash2})'

if __name__ == '__main__':
    s = "geeksforgeeks"

print("Hash")
#mid = time.time()
millisecondsStart = int(round(time.time() * 100000))
print("start " + str(millisecondsStart))
hash = Hash(s)
#end = time.time()
millisecondsEnd = int(round(time.time() * 100000))
print("end " + str(millisecondsEnd))
print(millisecondsEnd-millisecondsStart)


<!-- Heap sort -->

# Python program for implementation of heap Sort
 
# To heapify subtree rooted at index i.
# n is size of heap
 
 
def heapify(arr, N, i):
    largest = i  # Initialize largest as root
    l = 2 * i + 1     # left = 2*i + 1
    r = 2 * i + 2     # right = 2*i + 2
 
    # See if left child of root exists and is
    # greater than root
    if l < N and arr[largest] < arr[l]:
        largest = l
 
    # See if right child of root exists and is
    # greater than root
    if r < N and arr[largest] < arr[r]:
        largest = r
 
    # Change root, if needed
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap
 
        # Heapify the root.
        heapify(arr, N, largest)
 
# The main function to sort an array of given size
 
 
def heapSort(arr):
    N = len(arr)
 
    # Build a maxheap.
    for i in range(N//2 - 1, -1, -1):
        heapify(arr, N, i)
 
    # One by one extract elements
    for i in range(N-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap
        heapify(arr, i, 0)
 
 
# Driver's code
if __name__ == '__main__':
    print("Heap Sort")
    mid = time.time()
    hash = heapSort(data)
    end = time.time()
    print(end-mid)


    </py-script>
</body>

</html>