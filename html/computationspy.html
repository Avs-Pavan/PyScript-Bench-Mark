<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../css/computations.css">
    <script defer src="https://pyscript.net/alpha/pyscript.js"></script>
</head>

<body>
    <h1>PyScript computation benchmark</h1>
    <py-script>
<!-- import json
from js import console
from pyodide.http import open_url
# GET
start = time.time()
data = json.loads(open_url("https://raw.githubusercontent.com/kevinOcconer/million/main/million.json").read())
def mergeSort(arr):
    if len(arr) > 1:
 
         # Finding the mid of the array
        mid = len(arr)//2
 
        # Dividing the array elements
        L = arr[:mid]
 
        # into 2 halves
        R = arr[mid:]
 
        # Sorting the first half
        mergeSort(L)
 
        # Sorting the second half
        mergeSort(R)
 
        i = j = k = 0
 
        # Copy data to temp arrays L[] and R[]
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1
 
        # Checking if any element was left
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1
 
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1
print("merge sort started")
mid = time.time()
mergeSort(data)
end = time.time()
print(end-mid)
print("completed")        -->

<!-- matrix Multiplication -->

<!-- m1 = [[1,2],[3,4]]
m2 = [[5,6],[7,8]]

result = []
for i in range(2):
   row = []
   for j in range(2):
      row.append(0)
   result.append(row)
print("Matrix Multiplication:")
mid = time.time()
for i in range(2):
   for j in range(2):
      for k in range(2):
         result[i][j] += m1[i][k] * m2[k][j]
end = time.time()
print(end-mid) -->

<!-- DFS -->

<!-- '''Python program to print DFS traversal for complete graph'''
from collections import defaultdict
 
# this class represents a directed graph using adjacency list representation
 
 
class Graph:
    # Constructor
    def __init__(self):
        # default dictionary to store graph
        self.graph = defaultdict(list)
 
    # Function to add an edge to graph
    def addEdge(self, u, v):
        self.graph[u].append(v)
    # A function used by DFS
 
    def DFSUtil(self, v, visited):
        # Mark the current node as visited and print it
        visited.add(v)
        print(v,end=" ")
 
        # recur for all the vertices adjacent to this vertex
        for neighbour in self.graph[v]:
            if neighbour not in visited:
                self.DFSUtil(neighbour, visited)
        # The function to do DFS traversal. It uses recursive DFSUtil
 
    def DFS(self):
        # create a set to store all visited vertices
        visited = set()
        # call the recursive helper function to print DFS traversal starting from all
        # vertices one by one
        for vertex in self.graph:
            if vertex not in visited:
                self.DFSUtil(vertex, visited)
# Driver code
# create a graph given in the above diagram
 
print("Following is Depth First Traversal \n")
g = Graph()
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(2, 3)
g.addEdge(3, 3)
print("DFS")
mid = time.time()
g.DFS()
end = time.time()
print(end-mid) -->

<!-- Polynomial hash -->


class Hash:
    def __init__(self, s: str):
        self.p1, self.m1 = 31, 10**9 + 7
        self.p2, self.m2 = 37, 10**9 + 9
        self.hash1, self.hash2 = 0, 0
        self.compute_hashes(s)
    def compute_hashes(self, s: str):
        pow1, pow2 = 1, 1
        hash1, hash2 = 0, 0
        for ch in s:
            seed = 1 + ord(ch) - ord('a')
            hash1 = (hash1 + seed * pow1) % self.m1
            hash2 = (hash2 + seed * pow2) % self.m2
            pow1 = (pow1 * self.p1) % self.m1
            pow2 = (pow2 * self.p2) % self.m2
        self.hash1, self.hash2 = hash1, hash2

def __eq__(self, other):
    return self.hash1 == other.hash1 and self.hash2 == other.hash2

def __str__(self):
    return f'({self.hash1}, {self.hash2})'

if __name__ == '__main__':
    s = "geeksforgeeks"

print("Hash")
mid = time.time()
hash = Hash(s)
end = time.time()
print(end-mid)


    </py-script>
</body>

</html>